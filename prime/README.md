# prime

## A Turing machine to test primality

This short program implements a Turing Machine that uses 1 tape, 52 states, and 5 symbols to determine whether a positive integer given as input is a prime number.

All successive transitions are printed to `stdout`, and can thus easily be counted by piping the executable to `wc -l`.

Although it is quite difficult to calculate exact complexity of the algorithm used, two things can be said:

- Best-case is almost `O(1)` as testing divisibility by 2 is easy but a prerequisite is being at the end of the number, thus incurring a `Ω(lg n)`
- Worst-case seems reasonably close to `Θ(n lg²n)` according to experimental data

Fig1 plots the number of transitions T as a function of the number to be tested N. It is the direct output of executing `plotter.py`.

## How to run
```bash
$ gcc -o prime prime.c
```
If compilation fails, maybe your compiler does not support the GNU extension for statement expressions, in which case you should refer to the root `README.md` and replace the macro with one compatible with your compiler.

In that case, the appropriate part of the macro should be replaced with
```c
case _:*h=(c_==_?_:c_);h+="\000\002\001"[2 m_ 0]-1; if(n_==_){if(c_==_&&2 m_ 0==2){goto Q_;}else{goto Q##q;}}else{goto Q##n_;} \
case o:*h=(co==_?o:co);h+="\000\002\001"[2 mo 0]-1; if(no==_){if(co==_&&2 mo 0==2){goto Q_;}else{goto Q##q;}}else{goto Q##no;} \
case i:*h=(ci==_?i:ci);h+="\000\002\001"[2 mi 0]-1; if(ni==_){if(ci==_&&2 mi 0==2){goto Q_;}else{goto Q##q;}}else{goto Q##ni;} \
case O:*h=(cO==_?O:cO);h+="\000\002\001"[2 mO 0]-1; if(nO==_){if(cO==_&&2 mO 0==2){goto Q_;}else{goto Q##q;}}else{goto Q##nO;} \
case I:*h=(cI==_?I:cI);h+="\000\002\001"[2 mI 0]-1; if(nI==_){if(cI==_&&2 mI 0==2){goto Q_;}else{goto Q##q;}}else{goto Q##nI;} \
```
Which is logically equivalent.

For a simple run
```bash
$ ./prime
```
then enter the input as prompted (in base 10, a precalculation is performed to convert to base 2 internally).

For the graph
```bash
$ chmod u+x plotter.py
$ ./plotter
```
or
```bash
$ python3 plotter.py
```

(Requires `matplotlib`)

You may safely delete `save.txt`, as it is only used for caching and will be restored by the script. Be aware though that the cached results are worth several hours of computation.


The initialisation:
```c
for(int c=1;n;c<<=1){*(--h)=(n&c)?i:o;n&=~c;}
```
expands to
```c
for (int c = 1; n; c <<= 1) {      // for each bit
    *(--h) = (n & c) ? i : o ;     // write o (0) or i (1) to the tape
    n &= ~c ;                      // clear the bit in the source integer
}
```
and is just a compact way to convert the input to base 2.

### N.B.

This machine predates the creation of `tmake` (see in the project root), which is merely a generalization of this.
It was not generated from `tmake`, but rather served first as a proof of concept, then as a test to guide the creation of `tmake`.

Due to this, there are some slight differences between the header of this file and the template generated by `tmake`.


### Examples

```
input> 17

_______________________10001____________
[...]
_________________10001_10001_001________

Accept done
```
```
input> 6

_________________________110____________
[...]
_________________________110____________

Reject done
```
```
input> 2047

_________________11111111111____________
[...]
_____11111111111_00000000000_010111_____

Reject done
```
